import React, { useRef, useState, useEffect } from 'react';

var ViewMode;

(function (ViewMode) {
  ViewMode["QuarterDay"] = "Quarter Day";
  ViewMode["HalfDay"] = "Half Day";
  ViewMode["Day"] = "Day";
  ViewMode["Week"] = "Week";
  ViewMode["Month"] = "Month";
})(ViewMode || (ViewMode = {}));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

var addToDate = function addToDate(date, quantity, scale) {
  var newDate = new Date(date.getFullYear() + (scale === "year" ? quantity : 0), date.getMonth() + (scale === "month" ? quantity : 0), date.getDate() + (scale === "day" ? quantity : 0), date.getHours() + (scale === "hour" ? quantity : 0), date.getMinutes() + (scale === "minute" ? quantity : 0), date.getSeconds() + (scale === "second" ? quantity : 0), date.getMilliseconds() + (scale === "millisecond" ? quantity : 0));
  return newDate;
};
var startOfDate = function startOfDate(date, scale) {
  var scores = ["millisecond", "second", "minute", "hour", "day", "month", "year"];

  var shouldReset = function shouldReset(_scale) {
    var maxScore = scores.indexOf(scale);
    return scores.indexOf(_scale) <= maxScore;
  };

  var newDate = new Date(date.getFullYear(), shouldReset("year") ? 0 : date.getMonth(), shouldReset("month") ? 1 : date.getDate(), shouldReset("day") ? 0 : date.getHours(), shouldReset("hour") ? 0 : date.getMinutes(), shouldReset("minute") ? 0 : date.getSeconds(), shouldReset("second") ? 0 : date.getMilliseconds());
  return newDate;
};
var ganttDateRange = function ganttDateRange(tasks, viewMode) {
  var newStartDate = tasks[0].start;
  var newEndDate = tasks[0].end;

  for (var _iterator = _createForOfIteratorHelperLoose(tasks), _step; !(_step = _iterator()).done;) {
    var task = _step.value;

    if (task.start < newStartDate) {
      newStartDate = task.start;
    }

    if (task.end > newEndDate) {
      newEndDate = task.end;
    }
  }

  switch (viewMode) {
    case ViewMode.Month:
      newStartDate = addToDate(newStartDate, -1, "month");
      newStartDate = startOfDate(newStartDate, "month");
      newEndDate = addToDate(newEndDate, 1, "year");
      newEndDate = startOfDate(newEndDate, "year");
      break;

    case ViewMode.Week:
      newStartDate = startOfDate(newStartDate, "day");
      newEndDate = startOfDate(newEndDate, "day");
      newStartDate = addToDate(getMonday(newStartDate), -7, "day");
      newEndDate = addToDate(newEndDate, 1.5, "month");
      break;

    default:
      newStartDate = startOfDate(newStartDate, "day");
      newEndDate = startOfDate(newEndDate, "day");
      newStartDate = addToDate(newStartDate, -1, "day");
      newEndDate = addToDate(newEndDate, 19, "day");
      break;
  }

  return [newStartDate, newEndDate];
};
var seedDates = function seedDates(startDate, endDate, viewMode) {
  var currentDate = new Date(startDate);
  var dates = [currentDate];

  while (currentDate < endDate) {
    switch (viewMode) {
      case ViewMode.Month:
        currentDate = addToDate(currentDate, 1, "month");
        break;

      case ViewMode.Week:
        currentDate = addToDate(currentDate, 7, "day");
        break;

      case ViewMode.Day:
        currentDate = addToDate(currentDate, 1, "day");
        break;

      case ViewMode.HalfDay:
        currentDate = addToDate(currentDate, 12, "hour");
        break;

      case ViewMode.QuarterDay:
        currentDate = addToDate(currentDate, 6, "hour");
        break;
    }

    dates.push(currentDate);
  }

  return dates;
};
var getLocaleMonth = function getLocaleMonth(date, locale) {
  var bottomValue = new Intl.DateTimeFormat(locale, {
    month: "long"
  }).format(date);
  bottomValue = bottomValue.replace(bottomValue[0], bottomValue[0].toLocaleUpperCase());
  return bottomValue;
};

var getMonday = function getMonday(date) {
  var day = date.getDay();
  var diff = date.getDate() - day + (day === 0 ? -6 : 1);
  return new Date(date.setDate(diff));
};

var getWeekNumberISO8601 = function getWeekNumberISO8601(date) {
  var tmpDate = new Date(date.valueOf());
  var dayNumber = (tmpDate.getDay() + 6) % 7;
  tmpDate.setDate(tmpDate.getDate() - dayNumber + 3);
  var firstThursday = tmpDate.valueOf();
  tmpDate.setMonth(0, 1);

  if (tmpDate.getDay() !== 4) {
    tmpDate.setMonth(0, 1 + (4 - tmpDate.getDay() + 7) % 7);
  }

  var weekNumber = (1 + Math.ceil((firstThursday - tmpDate.valueOf()) / 604800000)).toString();

  if (weekNumber.length === 1) {
    return "0" + weekNumber;
  } else {
    return weekNumber;
  }
};

var styles = {"ganttTable":"_3_ygE","ganttTable_Header":"_1nBOt","ganttTable_HeaderSeparator":"_2eZzQ","ganttTable_HeaderItem":"_WuQ0f"};

var TaskListHeaderDefault = function TaskListHeaderDefault(_ref) {
  var headerHeight = _ref.headerHeight,
      fontFamily = _ref.fontFamily,
      fontSize = _ref.fontSize,
      rowWidth = _ref.rowWidth;
  return React.createElement("div", {
    className: styles.ganttTable,
    style: {
      fontFamily: fontFamily,
      fontSize: fontSize
    }
  }, React.createElement("div", {
    className: styles.ganttTable_Header,
    style: {
      height: headerHeight - 2
    }
  }, React.createElement("div", {
    className: styles.ganttTable_HeaderItem,
    style: {
      minWidth: rowWidth
    }
  }, "\xA0Name"), React.createElement("div", {
    className: styles.ganttTable_HeaderSeparator,
    style: {
      height: headerHeight * 0.5,
      marginTop: headerHeight * 0.2
    }
  }), React.createElement("div", {
    className: styles.ganttTable_HeaderItem,
    style: {
      minWidth: rowWidth
    }
  }, "\xA0From"), React.createElement("div", {
    className: styles.ganttTable_HeaderSeparator,
    style: {
      height: headerHeight * 0.5,
      marginTop: headerHeight * 0.25
    }
  }), React.createElement("div", {
    className: styles.ganttTable_HeaderItem,
    style: {
      minWidth: rowWidth
    }
  }, "\xA0To")));
};

var styles$1 = {"taskListWrapper":"_3ZbQT","taskListTableRow":"_34SS0","taskListCell":"_3lLk3"};

var TaskListTableDefault = function TaskListTableDefault(_ref) {
  var rowHeight = _ref.rowHeight,
      rowWidth = _ref.rowWidth,
      tasks = _ref.tasks,
      fontFamily = _ref.fontFamily,
      fontSize = _ref.fontSize,
      locale = _ref.locale;
  var dateTimeOptions = {
    weekday: "short",
    year: "numeric",
    month: "long",
    day: "numeric"
  };
  return React.createElement("div", {
    className: styles$1.taskListWrapper,
    style: {
      fontFamily: fontFamily,
      fontSize: fontSize
    }
  }, tasks.map(function (t) {
    return React.createElement("div", {
      className: styles$1.taskListTableRow,
      style: {
        height: rowHeight
      },
      key: t.id + "row"
    }, React.createElement("div", {
      className: styles$1.taskListCell,
      style: {
        minWidth: rowWidth,
        maxWidth: rowWidth
      },
      title: t.name
    }, "\xA0", t.name), React.createElement("div", {
      className: styles$1.taskListCell,
      style: {
        minWidth: rowWidth,
        maxWidth: rowWidth
      }
    }, "\xA0", t.start.toLocaleDateString(locale, dateTimeOptions)), React.createElement("div", {
      className: styles$1.taskListCell,
      style: {
        minWidth: rowWidth,
        maxWidth: rowWidth
      }
    }, "\xA0", t.end.toLocaleDateString(locale, dateTimeOptions)));
  }));
};

var styles$2 = {"tooltipDefaultContainer":"_3T42e","tooltipDefaultContainerParagraph":"_29NTg","tooltipDetailsContainer":"_25P-K"};

var Tooltip = function Tooltip(_ref) {
  var x = _ref.x,
      rowHeight = _ref.rowHeight,
      svgHeight = _ref.svgHeight,
      task = _ref.task,
      fontSize = _ref.fontSize,
      fontFamily = _ref.fontFamily,
      TooltipContent = _ref.TooltipContent;
  var tooltipRef = useRef(null);

  var _useState = useState(1000),
      toolWidth = _useState[0],
      setToolWidth = _useState[1];

  var _useState2 = useState((task.index - 1) * rowHeight),
      relatedY = _useState2[0],
      setRelatedY = _useState2[1];

  useEffect(function () {
    if (tooltipRef.current) {
      var tooltipHeight = tooltipRef.current.offsetHeight;
      var tooltipY = task.index * rowHeight + rowHeight;

      if (tooltipHeight > tooltipY) {
        setRelatedY(tooltipHeight * 0.5);
      } else if (tooltipY + tooltipHeight > svgHeight) {
        setRelatedY(svgHeight - tooltipHeight * 1.05);
      }

      setToolWidth(tooltipRef.current.scrollWidth * 1.1);
    }
  }, [tooltipRef, task]);
  return React.createElement("foreignObject", {
    x: x,
    y: relatedY,
    width: toolWidth,
    height: 1000
  }, React.createElement("div", {
    ref: tooltipRef,
    className: styles$2.tooltipDetailsContainer
  }, React.createElement(TooltipContent, {
    task: task,
    fontSize: fontSize,
    fontFamily: fontFamily
  })));
};
var StandardTooltipContent = function StandardTooltipContent(_ref2) {
  var task = _ref2.task,
      fontSize = _ref2.fontSize,
      fontFamily = _ref2.fontFamily;
  var style = {
    fontSize: fontSize,
    fontFamily: fontFamily
  };
  return React.createElement("div", {
    className: styles$2.tooltipDefaultContainer,
    style: style
  }, React.createElement("b", {
    style: {
      fontSize: fontSize + 6
    }
  }, task.name + ": " + task.start.getDate() + "-" + (task.start.getMonth() + 1) + "-" + task.start.getFullYear() + " - " + task.end.getDate() + "-" + (task.end.getMonth() + 1) + "-" + task.end.getFullYear()), React.createElement("p", {
    className: styles$2.tooltipDefaultContainerParagraph
  }, "Duration: " + ~~((task.end.getTime() - task.start.getTime()) / (1000 * 60 * 60 * 24)) + " day(s)"), React.createElement("p", {
    className: styles$2.tooltipDefaultContainerParagraph
  }, !!task.progress && "Progress: " + task.progress + " %"));
};

var styles$3 = {"scroll":"_3f9LK"};

var Scroll = function Scroll(_ref) {
  var scroll = _ref.scroll,
      ganttHeight = _ref.ganttHeight,
      ganttFullHeight = _ref.ganttFullHeight,
      headerHeight = _ref.headerHeight,
      onScroll = _ref.onScroll;
  var scrollRef = useRef(null);
  useEffect(function () {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scroll;
    }
  }, [scroll]);
  return React.createElement("div", {
    style: {
      height: ganttHeight,
      marginTop: headerHeight
    },
    className: styles$3.scroll,
    onScroll: onScroll,
    ref: scrollRef
  }, React.createElement("div", {
    style: {
      height: ganttFullHeight,
      width: 1
    }
  }));
};

var TaskList = function TaskList(_ref) {
  var headerHeight = _ref.headerHeight,
      fontFamily = _ref.fontFamily,
      fontSize = _ref.fontSize,
      rowWidth = _ref.rowWidth,
      rowHeight = _ref.rowHeight,
      scrollY = _ref.scrollY,
      tasks = _ref.tasks,
      selectedTaskId = _ref.selectedTaskId,
      setSelectedTask = _ref.setSelectedTask,
      locale = _ref.locale,
      ganttHeight = _ref.ganttHeight,
      horizontalContainerClass = _ref.horizontalContainerClass,
      TaskListHeader = _ref.TaskListHeader,
      TaskListTable = _ref.TaskListTable;
  var horizontalContainerRef = useRef(null);
  useEffect(function () {
    if (horizontalContainerRef.current) {
      horizontalContainerRef.current.scrollTop = scrollY;
    }
  }, [scrollY]);
  var headerProps = {
    headerHeight: headerHeight,
    fontFamily: fontFamily,
    fontSize: fontSize,
    rowWidth: rowWidth
  };
  var tableProps = {
    rowHeight: rowHeight,
    rowWidth: rowWidth,
    fontFamily: fontFamily,
    fontSize: fontSize,
    tasks: tasks,
    locale: locale,
    selectedTaskId: selectedTaskId,
    setSelectedTask: setSelectedTask
  };
  return React.createElement("div", null, React.createElement(TaskListHeader, Object.assign({}, headerProps)), React.createElement("div", {
    ref: horizontalContainerRef,
    className: horizontalContainerClass,
    style: ganttHeight ? {
      height: ganttHeight
    } : {}
  }, React.createElement(TaskListTable, Object.assign({}, tableProps))));
};

var styles$4 = {"ganttVerticalContainer":"_CZjuD","horizontalContainer":"_2B2zv","wrapper":"_3eULf"};

var styles$5 = {"gridRow":"_2dZTy","gridRowLine":"_3rUKi","gridTick":"_RuwuK"};

var GridBody = function GridBody(_ref) {
  var tasks = _ref.tasks,
      dates = _ref.dates,
      rowHeight = _ref.rowHeight,
      gridWidth = _ref.gridWidth,
      columnWidth = _ref.columnWidth,
      todayColor = _ref.todayColor;
  var y = 0;
  var gridRows = [];
  var rowLines = [React.createElement("line", {
    key: "RowLineFirst",
    x: "0",
    y1: 0,
    x2: gridWidth,
    y2: 0,
    className: styles$5.gridRowLine
  })];

  for (var _iterator = _createForOfIteratorHelperLoose(tasks), _step; !(_step = _iterator()).done;) {
    var task = _step.value;
    gridRows.push(React.createElement("rect", {
      key: "Row" + task.id,
      x: "0",
      y: y,
      width: gridWidth,
      height: rowHeight,
      className: styles$5.gridRow
    }));
    rowLines.push(React.createElement("line", {
      key: "RowLine" + task.id,
      x: "0",
      y1: y + rowHeight,
      x2: gridWidth,
      y2: y + rowHeight,
      className: styles$5.gridRowLine
    }));
    y += rowHeight;
  }

  var now = new Date();
  var tickX = 0;
  var ticks = [];
  var today = React.createElement("rect", null);

  for (var i = 0; i < dates.length; i++) {
    var date = dates[i];
    ticks.push(React.createElement("line", {
      key: date.getTime(),
      x1: tickX,
      y1: 0,
      x2: tickX,
      y2: y,
      className: styles$5.gridTick
    }));

    if (i + 1 !== dates.length && date.getTime() < now.getTime() && dates[i + 1].getTime() >= now.getTime() || i !== 0 && i + 1 === dates.length && date.getTime() < now.getTime() && addToDate(date, date.getTime() - dates[i - 1].getTime(), "millisecond").getTime() >= now.getTime()) {
      today = React.createElement("rect", {
        x: tickX,
        y: 0,
        width: columnWidth,
        height: y,
        fill: todayColor
      });
    }

    tickX += columnWidth;
  }

  return React.createElement("g", {
    className: "gridBody"
  }, React.createElement("g", {
    className: "rows"
  }, gridRows), React.createElement("g", {
    className: "rowLines"
  }, rowLines), React.createElement("g", {
    className: "ticks"
  }, ticks), React.createElement("g", {
    className: "today"
  }, today));
};

var Grid = function Grid(props) {
  return React.createElement("g", {
    className: "grid"
  }, React.createElement(GridBody, Object.assign({}, props)));
};

var styles$6 = {"calendarBottomText":"_9w8d5","calendarTopTick":"_1rLuZ","calendarTopText":"_2q1Kt","calendarHeader":"_35nLX"};

var TopPartOfCalendar = function TopPartOfCalendar(_ref) {
  var value = _ref.value,
      x1Line = _ref.x1Line,
      y1Line = _ref.y1Line,
      y2Line = _ref.y2Line,
      xText = _ref.xText,
      yText = _ref.yText;
  return React.createElement("g", {
    className: "calendarTop"
  }, React.createElement("line", {
    x1: x1Line,
    y1: y1Line,
    x2: x1Line,
    y2: y2Line,
    className: styles$6.calendarTopTick,
    key: value + "line"
  }), React.createElement("text", {
    key: value + "text",
    y: yText,
    x: xText,
    className: styles$6.calendarTopText
  }, value));
};

var Calendar = function Calendar(_ref) {
  var dates = _ref.dates,
      locale = _ref.locale,
      viewMode = _ref.viewMode,
      headerHeight = _ref.headerHeight,
      columnWidth = _ref.columnWidth,
      fontFamily = _ref.fontFamily,
      fontSize = _ref.fontSize;

  var getCalendarValuesForMonth = function getCalendarValuesForMonth() {
    var topValues = [];
    var bottomValues = [];
    var topDefaultWidth = columnWidth * 6;
    var topDefaultHeight = headerHeight * 0.5;

    for (var i = 0; i < dates.length; i++) {
      var date = dates[i];
      var bottomValue = getLocaleMonth(date, locale);
      bottomValues.push(React.createElement("text", {
        key: bottomValue + date.getFullYear(),
        y: headerHeight * 0.8,
        x: columnWidth * i + columnWidth * 0.5,
        className: styles$6.calendarBottomText
      }, bottomValue));

      if (i === 0 || date.getFullYear() !== dates[i - 1].getFullYear()) {
        var topValue = date.getFullYear().toString();
        topValues.push(React.createElement(TopPartOfCalendar, {
          key: topValue,
          value: topValue,
          x1Line: columnWidth * i,
          y1Line: 0,
          y2Line: topDefaultHeight,
          xText: topDefaultWidth + columnWidth * i - date.getMonth() * columnWidth,
          yText: topDefaultHeight * 0.9
        }));
      }
    }

    return [topValues, bottomValues];
  };

  var getCalendarValuesForWeek = function getCalendarValuesForWeek() {
    var topValues = [];
    var bottomValues = [];
    var weeksCount = 1;
    var topDefaultHeight = headerHeight * 0.5;

    for (var i = dates.length - 1; i >= 0; i--) {
      var date = dates[i];
      var topValue = "";

      if (i === 0 || date.getMonth() !== dates[i - 1].getMonth()) {
        topValue = getLocaleMonth(date, locale) + ", " + date.getFullYear();
      }

      var bottomValue = "W" + getWeekNumberISO8601(date);
      bottomValues.push(React.createElement("text", {
        key: date.getTime(),
        y: headerHeight * 0.8,
        x: columnWidth * i,
        className: styles$6.calendarBottomText
      }, bottomValue));

      if (topValue) {
        if (i !== dates.length - 1) {
          topValues.push(React.createElement(TopPartOfCalendar, {
            key: topValue,
            value: topValue,
            x1Line: columnWidth * i + weeksCount * columnWidth,
            y1Line: 0,
            y2Line: topDefaultHeight,
            xText: columnWidth * i + columnWidth * weeksCount * 0.5,
            yText: topDefaultHeight * 0.9
          }));
        }

        weeksCount = 0;
      }

      weeksCount++;
    }

    return [topValues, bottomValues];
  };

  var getCalendarValuesForDay = function getCalendarValuesForDay() {
    var topValues = [];
    var bottomValues = [];
    var topDefaultHeight = headerHeight * 0.5;

    for (var i = 0; i < dates.length; i++) {
      var date = dates[i];
      var bottomValue = date.getDate().toString();
      bottomValues.push(React.createElement("text", {
        key: date.getTime(),
        y: headerHeight * 0.8,
        x: columnWidth * i + columnWidth * 0.5,
        className: styles$6.calendarBottomText
      }, bottomValue));

      if (i + 1 !== dates.length && date.getMonth() !== dates[i + 1].getMonth()) {
        var topValue = getLocaleMonth(date, locale);
        topValues.push(React.createElement(TopPartOfCalendar, {
          key: topValue + date.getFullYear(),
          value: topValue,
          x1Line: columnWidth * (i + 1),
          y1Line: 0,
          y2Line: topDefaultHeight,
          xText: columnWidth * (i + 1) - date.getDate() * columnWidth * 0.5,
          yText: topDefaultHeight * 0.9
        }));
      }
    }

    return [topValues, bottomValues];
  };

  var getCalendarValuesForOther = function getCalendarValuesForOther() {
    var topValues = [];
    var bottomValues = [];
    var ticks = viewMode === ViewMode.HalfDay ? 2 : 4;
    var topDefaultHeight = headerHeight * 0.5;

    for (var i = 0; i < dates.length; i++) {
      var date = dates[i];
      var bottomValue = Intl.DateTimeFormat(locale, {
        hour: "numeric"
      }).format(date);
      bottomValues.push(React.createElement("text", {
        key: date.getTime(),
        y: headerHeight * 0.8,
        x: columnWidth * i,
        className: styles$6.calendarBottomText,
        fontFamily: fontFamily
      }, bottomValue));

      if (i === 0 || date.getDate() !== dates[i - 1].getDate()) {
        var topValue = date.getDate() + " " + getLocaleMonth(date, locale);
        topValues.push(React.createElement(TopPartOfCalendar, {
          key: topValue + date.getFullYear(),
          value: topValue,
          x1Line: columnWidth * i + ticks * columnWidth,
          y1Line: 0,
          y2Line: topDefaultHeight,
          xText: columnWidth * i + ticks * columnWidth * 0.5,
          yText: topDefaultHeight * 0.9
        }));
      }
    }

    return [topValues, bottomValues];
  };

  var topValues = [];
  var bottomValues = [];

  switch (viewMode) {
    case ViewMode.Month:
      var _getCalendarValuesFor = getCalendarValuesForMonth();

      topValues = _getCalendarValuesFor[0];
      bottomValues = _getCalendarValuesFor[1];
      break;

    case ViewMode.Week:
      var _getCalendarValuesFor2 = getCalendarValuesForWeek();

      topValues = _getCalendarValuesFor2[0];
      bottomValues = _getCalendarValuesFor2[1];
      break;

    case ViewMode.Day:
      var _getCalendarValuesFor3 = getCalendarValuesForDay();

      topValues = _getCalendarValuesFor3[0];
      bottomValues = _getCalendarValuesFor3[1];
      break;

    default:
      var _getCalendarValuesFor4 = getCalendarValuesForOther();

      topValues = _getCalendarValuesFor4[0];
      bottomValues = _getCalendarValuesFor4[1];
      break;
  }

  return React.createElement("g", {
    className: "calendar",
    fontSize: fontSize,
    fontFamily: fontFamily
  }, React.createElement("rect", {
    x: 0,
    y: 0,
    width: columnWidth * dates.length,
    height: headerHeight,
    className: styles$6.calendarHeader
  }), bottomValues, " ", topValues);
};

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var convertToBarTasks = function convertToBarTasks(tasks, dates, columnWidth, rowHeight, barFill, barCornerRadius, handleWidth, barProgressColor, barProgressSelectedColor, barBackgroundColor, barBackgroundSelectedColor) {
  var dateDelta = dates[1].getTime() - dates[0].getTime() - dates[1].getTimezoneOffset() * 60 * 1000 + dates[0].getTimezoneOffset() * 60 * 1000;
  var taskHeight = rowHeight * barFill / 100;
  var barTasks = tasks.map(function (t, i) {
    return convertToBarTask(t, i, dates, dateDelta, columnWidth, rowHeight, taskHeight, barCornerRadius, handleWidth, barProgressColor, barProgressSelectedColor, barBackgroundColor, barBackgroundSelectedColor);
  });
  barTasks = barTasks.map(function (task, i) {
    var dependencies = task.dependencies || [];

    var _loop = function _loop(j) {
      var dependence = barTasks.findIndex(function (value) {
        return value.id === dependencies[j];
      });
      if (dependence !== -1) barTasks[dependence].barChildren.push(i);
    };

    for (var j = 0; j < dependencies.length; j++) {
      _loop(j);
    }

    return task;
  });
  return barTasks;
};
var convertToBarTask = function convertToBarTask(task, index, dates, dateDelta, columnWidth, rowHeight, taskHeight, barCornerRadius, handleWidth, barProgressColor, barProgressSelectedColor, barBackgroundColor, barBackgroundSelectedColor) {
  var x1 = taskXCoordinate(task.start, dates, dateDelta, columnWidth);
  var x2 = taskXCoordinate(task.end, dates, dateDelta, columnWidth);
  var y = taskYCoordinate(index, rowHeight, taskHeight);

  var styles = _extends({
    backgroundColor: barBackgroundColor,
    backgroundSelectedColor: barBackgroundSelectedColor,
    progressColor: barProgressColor,
    progressSelectedColor: barProgressSelectedColor
  }, task.styles);

  return _extends({}, task, {
    x1: x1,
    x2: x2,
    y: y,
    index: index,
    barCornerRadius: barCornerRadius,
    handleWidth: handleWidth,
    height: taskHeight,
    barChildren: [],
    styles: styles
  });
};
var taskXCoordinate = function taskXCoordinate(xDate, dates, dateDelta, columnWidth) {
  var index = ~~((xDate.getTime() - dates[0].getTime() + xDate.getTimezoneOffset() - dates[0].getTimezoneOffset()) / dateDelta);
  var x = Math.round((index + (xDate.getTime() - dates[index].getTime() - xDate.getTimezoneOffset() * 60 * 1000 + dates[index].getTimezoneOffset() * 60 * 1000) / dateDelta) * columnWidth);
  return x;
};
var taskYCoordinate = function taskYCoordinate(index, rowHeight, taskHeight) {
  var y = index * rowHeight + (rowHeight - taskHeight) / 2;
  return y;
};
var progressWithByParams = function progressWithByParams(taskX1, taskX2, progress) {
  return (taskX2 - taskX1) * progress * 0.01;
};
var progressByX = function progressByX(x, task) {
  if (x >= task.x2) return 100;else if (x <= task.x1) return 0;else {
    var barWidth = task.x2 - task.x1;
    var progressPercent = Math.round((x - task.x1) * 100 / barWidth);
    return progressPercent;
  }
};
var getProgressPoint = function getProgressPoint(progressX, taskY, taskHeight) {
  var point = [progressX - 5, taskY + taskHeight, progressX + 5, taskY + taskHeight, progressX, taskY + taskHeight - 8.66];
  return point.join(",");
};
var startByX = function startByX(x, xStep, task) {
  if (x >= task.x2 - task.handleWidth * 2) {
    x = task.x2 - task.handleWidth * 2;
  }

  var steps = Math.round((x - task.x1) / xStep);
  var additionalXValue = steps * xStep;
  var newX = task.x1 + additionalXValue;
  return newX;
};
var endByX = function endByX(x, xStep, task) {
  if (x <= task.x1 + task.handleWidth * 2) {
    x = task.x1 + task.handleWidth * 2;
  }

  var steps = Math.round((x - task.x2) / xStep);
  var additionalXValue = steps * xStep;
  var newX = task.x2 + additionalXValue;
  return newX;
};
var moveByX = function moveByX(x, xStep, task) {
  var steps = Math.round((x - task.x1) / xStep);
  var additionalXValue = steps * xStep;
  var newX1 = task.x1 + additionalXValue;
  var newX2 = newX1 + task.x2 - task.x1;
  return [newX1, newX2];
};
var dateByX = function dateByX(x, taskX, taskDate, xStep, timeStep) {
  var newDate = new Date((x - taskX) / xStep * timeStep + taskDate.getTime());
  newDate = new Date(newDate.getTime() + (newDate.getTimezoneOffset() - taskDate.getTimezoneOffset()) * 60000);
  return newDate;
};
var handleTaskBySVGMouseEvent = function handleTaskBySVGMouseEvent(svgX, action, selectedTask, xStep, timeStep, initEventX1Delta) {
  var changedTask = _extends({}, selectedTask);

  var isChanged = false;

  switch (action) {
    case "progress":
      changedTask.progress = progressByX(svgX, selectedTask);
      isChanged = changedTask.progress !== selectedTask.progress;
      break;

    case "start":
      {
        var newX1 = startByX(svgX, xStep, selectedTask);
        changedTask.x1 = newX1;
        isChanged = changedTask.x1 !== selectedTask.x1;

        if (isChanged) {
          changedTask.start = dateByX(newX1, selectedTask.x1, selectedTask.start, xStep, timeStep);
        }

        break;
      }

    case "end":
      {
        var newX2 = endByX(svgX, xStep, selectedTask);
        changedTask.x2 = newX2;
        isChanged = changedTask.x2 !== selectedTask.x2;

        if (isChanged) {
          changedTask.end = dateByX(newX2, selectedTask.x2, selectedTask.end, xStep, timeStep);
        }

        break;
      }

    case "move":
      {
        var _moveByX = moveByX(svgX - initEventX1Delta, xStep, selectedTask),
            newMoveX1 = _moveByX[0],
            newMoveX2 = _moveByX[1];

        isChanged = newMoveX1 !== selectedTask.x1;

        if (isChanged) {
          changedTask.start = dateByX(newMoveX1, selectedTask.x1, selectedTask.start, xStep, timeStep);
          changedTask.end = dateByX(newMoveX2, selectedTask.x2, selectedTask.end, xStep, timeStep);
          changedTask.x1 = newMoveX1;
          changedTask.x2 = newMoveX2;
        }

        break;
      }
  }

  return {
    isChanged: isChanged,
    changedTask: changedTask
  };
};

var styles$7 = {"barWrapper":"_1gfz9","barHandle":"_I78P8","barLabel":"_1nTVz","barLabelOutside":"_h9J4Q","barBackground":"_3xu5M"};

var BarDisplay = function BarDisplay(_ref) {
  var x = _ref.x,
      y = _ref.y,
      width = _ref.width,
      height = _ref.height,
      isSelected = _ref.isSelected,
      progressWidth = _ref.progressWidth,
      barCornerRadius = _ref.barCornerRadius,
      text = _ref.text,
      hasChild = _ref.hasChild,
      arrowIndent = _ref.arrowIndent,
      styles = _ref.styles,
      onMouseDown = _ref.onMouseDown;
  var textRef = useRef(null);

  var _useState = useState(true),
      isTextInside = _useState[0],
      setIsTextInside = _useState[1];

  useEffect(function () {
    if (textRef.current) setIsTextInside(textRef.current.getBBox().width < width);
  }, [textRef, width]);

  var getProcessColor = function getProcessColor() {
    return isSelected ? styles.progressSelectedColor : styles.progressColor;
  };

  var getBarColor = function getBarColor() {
    return isSelected ? styles.backgroundSelectedColor : styles.backgroundColor;
  };

  var getX = function getX() {
    return isTextInside ? x + width * 0.5 : x + width + arrowIndent * +hasChild + arrowIndent * 0.2;
  };

  return React.createElement("g", {
    onMouseDown: onMouseDown
  }, React.createElement("rect", {
    x: x,
    width: width,
    y: y,
    height: height,
    ry: barCornerRadius,
    rx: barCornerRadius,
    fill: getBarColor(),
    className: styles$7.barBackground
  }), React.createElement("rect", {
    x: x,
    width: progressWidth,
    y: y,
    height: height,
    ry: barCornerRadius,
    rx: barCornerRadius,
    fill: getProcessColor()
  }), React.createElement("text", {
    x: getX(),
    y: y + height * 0.5,
    className: isTextInside ? styles$7.barLabel :  styles$7.barLabelOutside,
    ref: textRef
  }, text));
};

var BarDateHandle = function BarDateHandle(_ref) {
  var x = _ref.x,
      y = _ref.y,
      width = _ref.width,
      height = _ref.height,
      barCornerRadius = _ref.barCornerRadius,
      onMouseDown = _ref.onMouseDown;
  return React.createElement("rect", {
    x: x,
    y: y,
    width: width,
    height: height,
    className: styles$7.barHandle,
    ry: barCornerRadius,
    rx: barCornerRadius,
    onMouseDown: onMouseDown
  });
};

var BarProgressHandle = function BarProgressHandle(_ref) {
  var progressPoint = _ref.progressPoint,
      onMouseDown = _ref.onMouseDown;
  return React.createElement("polygon", {
    className: styles$7.barHandle,
    points: progressPoint,
    onMouseDown: onMouseDown
  });
};

var Bar = function Bar(_ref) {
  var task = _ref.task,
      arrowIndent = _ref.arrowIndent,
      isProgressChangeable = _ref.isProgressChangeable,
      isDateChangeable = _ref.isDateChangeable,
      onEventStart = _ref.onEventStart,
      isDelete = _ref.isDelete,
      isSelected = _ref.isSelected;
  var progressWidth = progressWithByParams(task.x1, task.x2, task.progress);
  var progressPoint = getProgressPoint(progressWidth + task.x1, task.y, task.height);
  return React.createElement("g", {
    className: styles$7.barWrapper,
    tabIndex: 0,
    onKeyDown: function onKeyDown(e) {
      switch (e.key) {
        case "Delete":
          {
            if (isDelete) onEventStart("delete", task, e);
            break;
          }
      }

      e.stopPropagation();
    },
    onMouseEnter: function onMouseEnter(e) {
      onEventStart("mouseenter", task, e);
    },
    onMouseLeave: function onMouseLeave(e) {
      onEventStart("mouseleave", task, e);
    },
    onDoubleClick: function onDoubleClick(e) {
      onEventStart("dblclick", task, e);
    },
    onFocus: function onFocus() {
      onEventStart("select", task);
    }
  }, React.createElement(BarDisplay, {
    x: task.x1,
    y: task.y,
    width: task.x2 - task.x1,
    height: task.height,
    progressWidth: progressWidth,
    barCornerRadius: task.barCornerRadius,
    text: task.name,
    hasChild: task.barChildren.length > 0,
    arrowIndent: arrowIndent,
    styles: task.styles,
    isSelected: isSelected,
    onMouseDown: function onMouseDown(e) {
      isDateChangeable && onEventStart("move", task, e);
    }
  }), React.createElement("g", {
    className: "handleGroup"
  }, isDateChangeable && React.createElement("g", null, React.createElement(BarDateHandle, {
    x: task.x1 + 1,
    y: task.y + 1,
    width: task.handleWidth,
    height: task.height - 2,
    barCornerRadius: task.barCornerRadius,
    onMouseDown: function onMouseDown(e) {
      onEventStart("start", task, e);
    }
  }), React.createElement(BarDateHandle, {
    x: task.x2 - task.handleWidth - 1,
    y: task.y + 1,
    width: task.handleWidth,
    height: task.height - 2,
    barCornerRadius: task.barCornerRadius,
    onMouseDown: function onMouseDown(e) {
      onEventStart("end", task, e);
    }
  })), isProgressChangeable && React.createElement(BarProgressHandle, {
    progressPoint: progressPoint,
    onMouseDown: function onMouseDown(e) {
      onEventStart("progress", task, e);
    }
  })));
};

var Arrow = function Arrow(_ref) {
  var taskFrom = _ref.taskFrom,
      taskTo = _ref.taskTo,
      rowHeight = _ref.rowHeight,
      arrowIndent = _ref.arrowIndent;
  var indexCompare = taskFrom.index > taskTo.index ? -1 : 1;
  var taskToEndPosition = taskTo.y + taskTo.height / 2;
  var path = "M " + taskFrom.x2 + " " + (taskFrom.y + taskFrom.height / 2) + " \n  h " + arrowIndent + " \n  v " + indexCompare * rowHeight / 2 + " \n  H " + (taskTo.x1 - arrowIndent) + " \n  V " + taskToEndPosition + " \n  h " + arrowIndent;
  var trianglePoints = taskTo.x1 + "," + taskToEndPosition + " \n  " + (taskTo.x1 - 5) + "," + (taskToEndPosition - 5) + " \n  " + (taskTo.x1 - 5) + "," + (taskToEndPosition + 5);
  return React.createElement("g", {
    className: "arrow"
  }, React.createElement("path", {
    strokeWidth: "1.5",
    d: path,
    fill: "none"
  }), React.createElement("polygon", {
    points: trianglePoints
  }));
};

function isKeyboardEvent(event) {
  return event.key !== undefined;
}

var TaskGanttContent = function TaskGanttContent(_ref) {
  var _svg$current;

  var tasks = _ref.tasks,
      dates = _ref.dates,
      selectedTask = _ref.selectedTask,
      rowHeight = _ref.rowHeight,
      barCornerRadius = _ref.barCornerRadius,
      columnWidth = _ref.columnWidth,
      barFill = _ref.barFill,
      barProgressColor = _ref.barProgressColor,
      barProgressSelectedColor = _ref.barProgressSelectedColor,
      barBackgroundColor = _ref.barBackgroundColor,
      barBackgroundSelectedColor = _ref.barBackgroundSelectedColor,
      handleWidth = _ref.handleWidth,
      timeStep = _ref.timeStep,
      svg = _ref.svg,
      svgHeight = _ref.svgHeight,
      arrowColor = _ref.arrowColor,
      arrowIndent = _ref.arrowIndent,
      fontFamily = _ref.fontFamily,
      fontSize = _ref.fontSize,
      setSelectedTask = _ref.setSelectedTask,
      onTasksChange = _ref.onTasksChange,
      onDateChange = _ref.onDateChange,
      onProgressChange = _ref.onProgressChange,
      onDoubleClick = _ref.onDoubleClick,
      onTaskDelete = _ref.onTaskDelete,
      TooltipContent = _ref.TooltipContent;
  var point = svg === null || svg === void 0 ? void 0 : (_svg$current = svg.current) === null || _svg$current === void 0 ? void 0 : _svg$current.createSVGPoint();

  var _useState = useState({
    action: ""
  }),
      barEvent = _useState[0],
      setBarEvent = _useState[1];

  var _useState2 = useState([]),
      barTasks = _useState2[0],
      setBarTasks = _useState2[1];

  var _useState3 = useState(null),
      failedTask = _useState3[0],
      setFailedTask = _useState3[1];

  var _useState4 = useState(0),
      xStep = _useState4[0],
      setXStep = _useState4[1];

  var _useState5 = useState(0),
      initEventX1Delta = _useState5[0],
      setInitEventX1Delta = _useState5[1];

  var _useState6 = useState(false),
      isMoving = _useState6[0],
      setIsMoving = _useState6[1];

  useEffect(function () {
    var dateDelta = dates[1].getTime() - dates[0].getTime() - dates[1].getTimezoneOffset() * 60 * 1000 + dates[0].getTimezoneOffset() * 60 * 1000;
    var newXStep = timeStep * columnWidth / dateDelta;
    setXStep(newXStep);
  }, [columnWidth, dates, timeStep]);
  useEffect(function () {
    setBarTasks(convertToBarTasks(tasks, dates, columnWidth, rowHeight, barFill, barCornerRadius, handleWidth, barProgressColor, barProgressSelectedColor, barBackgroundColor, barBackgroundSelectedColor));
  }, [tasks, rowHeight, barCornerRadius, columnWidth, dates, barFill, handleWidth, barProgressColor, barProgressSelectedColor, barBackgroundColor, barBackgroundSelectedColor]);
  useEffect(function () {
    if (failedTask) {
      var newTasks = barTasks.map(function (t) {
        return t.id === failedTask.id ? failedTask : t;
      });
      onTasksChange(newTasks);
      setFailedTask(null);
    }
  }, [failedTask, barTasks]);
  useEffect(function () {
    var handleMouseMove = function handleMouseMove(event) {
      try {
        var _svg$current$getScree;

        if (!barEvent.changedTask || !point || !(svg === null || svg === void 0 ? void 0 : svg.current)) return Promise.resolve();
        event.preventDefault();
        point.x = event.clientX;
        var cursor = point.matrixTransform(svg === null || svg === void 0 ? void 0 : (_svg$current$getScree = svg.current.getScreenCTM()) === null || _svg$current$getScree === void 0 ? void 0 : _svg$current$getScree.inverse());

        var _handleTaskBySVGMouse = handleTaskBySVGMouseEvent(cursor.x, barEvent.action, barEvent.changedTask, xStep, timeStep, initEventX1Delta),
            isChanged = _handleTaskBySVGMouse.isChanged,
            changedTask = _handleTaskBySVGMouse.changedTask;

        if (isChanged) {
          setBarTasks(barTasks.map(function (t) {
            return t.id === changedTask.id ? changedTask : t;
          }));
          setBarEvent(_extends({}, barEvent, {
            changedTask: changedTask
          }));
        }

        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    };

    var handleMouseUp = function handleMouseUp(event) {
      try {
        var _svg$current$getScree2;

        var _temp6 = function _temp6() {
          if (!operationSuccess) {
            setFailedTask(originalTask);
          }
        };

        var _selectedTask = barEvent.changedTask,
            action = barEvent.action,
            originalTask = barEvent.originalTask;
        if (!_selectedTask || !point || !(svg === null || svg === void 0 ? void 0 : svg.current) || !originalTask) return Promise.resolve();
        event.preventDefault();
        point.x = event.clientX;
        var cursor = point.matrixTransform(svg === null || svg === void 0 ? void 0 : (_svg$current$getScree2 = svg.current.getScreenCTM()) === null || _svg$current$getScree2 === void 0 ? void 0 : _svg$current$getScree2.inverse());

        var _handleTaskBySVGMouse2 = handleTaskBySVGMouseEvent(cursor.x, action, _selectedTask, xStep, timeStep, initEventX1Delta),
            changedTask = _handleTaskBySVGMouse2.changedTask;

        var isNotLikeOriginal = originalTask.start !== changedTask.start || originalTask.end !== changedTask.end || originalTask.progress !== changedTask.progress;
        svg.current.removeEventListener("mousemove", handleMouseMove);
        svg.current.removeEventListener("mouseup", handleMouseUp);
        setBarEvent({
          action: ""
        });
        setIsMoving(false);
        var newTasks = barTasks.map(function (t) {
          return t.id === changedTask.id ? changedTask : t;
        });
        onTasksChange(newTasks);
        var operationSuccess = true;

        var _temp7 = function () {
          if ((action === "move" || action === "end" || action === "start") && onDateChange && isNotLikeOriginal) {
            var _temp8 = _catch(function () {
              return Promise.resolve(onDateChange(changedTask)).then(function (result) {
                if (result !== undefined) {
                  operationSuccess = result;
                }
              });
            }, function () {
              operationSuccess = false;
            });

            if (_temp8 && _temp8.then) return _temp8.then(function () {});
          } else {
            var _temp9 = function () {
              if (onProgressChange && isNotLikeOriginal) {
                var _temp10 = _catch(function () {
                  return Promise.resolve(onProgressChange(changedTask)).then(function (result) {
                    if (result !== undefined) {
                      operationSuccess = result;
                    }
                  });
                }, function () {
                  operationSuccess = false;
                });

                if (_temp10 && _temp10.then) return _temp10.then(function () {});
              }
            }();

            if (_temp9 && _temp9.then) return _temp9.then(function () {});
          }
        }();

        return Promise.resolve(_temp7 && _temp7.then ? _temp7.then(_temp6) : _temp6(_temp7));
      } catch (e) {
        return Promise.reject(e);
      }
    };

    if (!isMoving && (barEvent.action === "move" || barEvent.action === "end" || barEvent.action === "start" || barEvent.action === "progress") && (svg === null || svg === void 0 ? void 0 : svg.current)) {
      svg.current.addEventListener("mousemove", handleMouseMove);
      svg.current.addEventListener("mouseup", handleMouseUp);
      setIsMoving(true);
    }
  }, [barTasks, barEvent, xStep, initEventX1Delta, onProgressChange, timeStep, onDateChange, svg, isMoving]);

  var handleBarEventStart = function handleBarEventStart(action, task, event) {
    try {
      return Promise.resolve(function () {
        if (!event) {
          if (action === "select") {
            setSelectedTask(task.id);
          }
        } else return function () {
            if (isKeyboardEvent(event)) {
              var _temp14 = function () {
                if (action === "delete") {
                  var _temp15 = function () {
                    if (onTaskDelete) {
                      var _temp16 = _catch(function () {
                        return Promise.resolve(onTaskDelete(task)).then(function (result) {
                          if (result !== undefined && result) {
                            var newTasks = barTasks.filter(function (t) {
                              return t.id !== task.id;
                            });
                            onTasksChange(newTasks);
                            setSelectedTask("");
                          }
                        });
                      }, function (error) {
                        console.error("Error on Delete. " + error);
                      });

                      if (_temp16 && _temp16.then) return _temp16.then(function () {});
                    }
                  }();

                  if (_temp15 && _temp15.then) return _temp15.then(function () {});
                }
              }();

              if (_temp14 && _temp14.then) return _temp14.then(function () {});
            } else if (action === "mouseenter") {
                if (!barEvent.action) {
                  setBarEvent({
                    action: action,
                    changedTask: task,
                    originalTask: task
                  });
                }
              } else if (action === "mouseleave") {
                if (barEvent.action === "mouseenter") {
                  setBarEvent({
                    action: ""
                  });
                }
              } else if (action === "dblclick") {
                !!onDoubleClick && onDoubleClick(task);
              } else if (action === "move") {
                  var _svg$current$getScree3;

                  if (!(svg === null || svg === void 0 ? void 0 : svg.current) || !point) return;
                  point.x = event.clientX;
                  var cursor = point.matrixTransform((_svg$current$getScree3 = svg.current.getScreenCTM()) === null || _svg$current$getScree3 === void 0 ? void 0 : _svg$current$getScree3.inverse());
                  setInitEventX1Delta(cursor.x - task.x1);
                  setBarEvent({
                    action: action,
                    changedTask: task,
                    originalTask: task
                  });
                } else {
                  setBarEvent({
                    action: action,
                    changedTask: task,
                    originalTask: task
                  });
                }
          }();
      }());
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return React.createElement("g", {
    className: "content"
  }, React.createElement("g", {
    className: "arrows",
    fill: arrowColor,
    stroke: arrowColor
  }, barTasks.map(function (task) {
    return task.barChildren.map(function (child) {
      return React.createElement(Arrow, {
        key: "Arrow from " + task.id + " to " + barTasks[child].id,
        taskFrom: task,
        taskTo: barTasks[child],
        rowHeight: rowHeight,
        arrowIndent: arrowIndent
      });
    });
  })), React.createElement("g", {
    className: "bar",
    fontFamily: fontFamily,
    fontSize: fontSize
  }, barTasks.map(function (task) {
    return React.createElement(Bar, {
      task: task,
      arrowIndent: arrowIndent,
      isProgressChangeable: !!onProgressChange && !task.isDisabled,
      isDateChangeable: !!onDateChange && !task.isDisabled,
      isDelete: !task.isDisabled,
      onEventStart: handleBarEventStart,
      key: task.id,
      isSelected: task.id === selectedTask
    });
  })), React.createElement("g", {
    className: "toolTip"
  }, barEvent.changedTask && React.createElement(Tooltip, {
    x: barEvent.changedTask.x2 + arrowIndent + arrowIndent * 0.5,
    rowHeight: rowHeight,
    svgHeight: svgHeight,
    task: barEvent.changedTask,
    fontFamily: fontFamily,
    fontSize: fontSize,
    TooltipContent: TooltipContent
  })));
};

var TaskGantt = function TaskGantt(_ref) {
  var gridProps = _ref.gridProps,
      calendarProps = _ref.calendarProps,
      barProps = _ref.barProps,
      ganttHeight = _ref.ganttHeight,
      scrollY = _ref.scrollY,
      scrollX = _ref.scrollX,
      onScroll = _ref.onScroll;
  var ganttSVGRef = useRef(null);
  var horizontalContainerRef = useRef(null);
  var verticalContainerRef = useRef(null);

  var newBarProps = _extends({}, barProps, {
    svg: ganttSVGRef
  });

  useEffect(function () {
    if (horizontalContainerRef.current) {
      horizontalContainerRef.current.scrollTop = scrollY;
    }
  }, [scrollY]);
  useEffect(function () {
    if (verticalContainerRef.current) {
      verticalContainerRef.current.scrollLeft = scrollX;
    }
  }, [scrollX]);
  return React.createElement("div", {
    className: styles$4.ganttVerticalContainer,
    ref: verticalContainerRef,
    onScroll: onScroll
  }, React.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: gridProps.gridWidth,
    height: calendarProps.headerHeight,
    fontFamily: barProps.fontFamily
  }, React.createElement(Calendar, Object.assign({}, calendarProps))), React.createElement("div", {
    ref: horizontalContainerRef,
    className: styles$4.horizontalContainer,
    style: ganttHeight ? {
      height: ganttHeight,
      width: gridProps.gridWidth
    } : {
      width: gridProps.gridWidth
    }
  }, React.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: gridProps.gridWidth,
    height: barProps.rowHeight * barProps.tasks.length,
    fontFamily: barProps.fontFamily,
    ref: ganttSVGRef
  }, React.createElement(Grid, Object.assign({}, gridProps)), React.createElement(TaskGanttContent, Object.assign({}, newBarProps)))));
};

var Gantt = function Gantt(_ref) {
  var tasks = _ref.tasks,
      _ref$headerHeight = _ref.headerHeight,
      headerHeight = _ref$headerHeight === void 0 ? 50 : _ref$headerHeight,
      _ref$columnWidth = _ref.columnWidth,
      columnWidth = _ref$columnWidth === void 0 ? 60 : _ref$columnWidth,
      _ref$listCellWidth = _ref.listCellWidth,
      listCellWidth = _ref$listCellWidth === void 0 ? "155px" : _ref$listCellWidth,
      _ref$rowHeight = _ref.rowHeight,
      rowHeight = _ref$rowHeight === void 0 ? 50 : _ref$rowHeight,
      _ref$ganttHeight = _ref.ganttHeight,
      ganttHeight = _ref$ganttHeight === void 0 ? 0 : _ref$ganttHeight,
      _ref$viewMode = _ref.viewMode,
      viewMode = _ref$viewMode === void 0 ? ViewMode.Day : _ref$viewMode,
      _ref$locale = _ref.locale,
      locale = _ref$locale === void 0 ? "en-GB" : _ref$locale,
      _ref$barFill = _ref.barFill,
      barFill = _ref$barFill === void 0 ? 60 : _ref$barFill,
      _ref$barCornerRadius = _ref.barCornerRadius,
      barCornerRadius = _ref$barCornerRadius === void 0 ? 3 : _ref$barCornerRadius,
      _ref$barProgressColor = _ref.barProgressColor,
      barProgressColor = _ref$barProgressColor === void 0 ? "#a3a3ff" : _ref$barProgressColor,
      _ref$barProgressSelec = _ref.barProgressSelectedColor,
      barProgressSelectedColor = _ref$barProgressSelec === void 0 ? "#8282f5" : _ref$barProgressSelec,
      _ref$barBackgroundCol = _ref.barBackgroundColor,
      barBackgroundColor = _ref$barBackgroundCol === void 0 ? "#b8c2cc" : _ref$barBackgroundCol,
      _ref$barBackgroundSel = _ref.barBackgroundSelectedColor,
      barBackgroundSelectedColor = _ref$barBackgroundSel === void 0 ? "#aeb8c2" : _ref$barBackgroundSel,
      _ref$handleWidth = _ref.handleWidth,
      handleWidth = _ref$handleWidth === void 0 ? 8 : _ref$handleWidth,
      _ref$timeStep = _ref.timeStep,
      timeStep = _ref$timeStep === void 0 ? 300000 : _ref$timeStep,
      _ref$arrowColor = _ref.arrowColor,
      arrowColor = _ref$arrowColor === void 0 ? "grey" : _ref$arrowColor,
      _ref$fontFamily = _ref.fontFamily,
      fontFamily = _ref$fontFamily === void 0 ? "Arial, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue" : _ref$fontFamily,
      _ref$fontSize = _ref.fontSize,
      fontSize = _ref$fontSize === void 0 ? "14px" : _ref$fontSize,
      _ref$arrowIndent = _ref.arrowIndent,
      arrowIndent = _ref$arrowIndent === void 0 ? 20 : _ref$arrowIndent,
      _ref$todayColor = _ref.todayColor,
      todayColor = _ref$todayColor === void 0 ? "rgba(252, 248, 227, 0.5)" : _ref$todayColor,
      _ref$TooltipContent = _ref.TooltipContent,
      TooltipContent = _ref$TooltipContent === void 0 ? StandardTooltipContent : _ref$TooltipContent,
      _ref$TaskListHeader = _ref.TaskListHeader,
      TaskListHeader = _ref$TaskListHeader === void 0 ? TaskListHeaderDefault : _ref$TaskListHeader,
      _ref$TaskListTable = _ref.TaskListTable,
      TaskListTable = _ref$TaskListTable === void 0 ? TaskListTableDefault : _ref$TaskListTable,
      onDateChange = _ref.onDateChange,
      onProgressChange = _ref.onProgressChange,
      onDoubleClick = _ref.onDoubleClick,
      onTaskDelete = _ref.onTaskDelete,
      onSelect = _ref.onSelect;
  var wrapperRef = useRef(null);

  var _useState = useState(tasks),
      ganttTasks = _useState[0],
      setGanttTasks = _useState[1];

  var _useState2 = useState(""),
      selectedTask = _useState2[0],
      setSelectedTask = _useState2[1];

  var _useState3 = useState(0),
      scrollY = _useState3[0],
      setScrollY = _useState3[1];

  var _useState4 = useState(0),
      scrollX = _useState4[0],
      setScrollX = _useState4[1];

  var _useState5 = useState(false),
      ignoreScrollEvent = _useState5[0],
      setIgnoreScrollEvent = _useState5[1];

  var _ganttDateRange = ganttDateRange(ganttTasks, viewMode),
      startDate = _ganttDateRange[0],
      endDate = _ganttDateRange[1];

  var dates = seedDates(startDate, endDate, viewMode);
  var svgHeight = rowHeight * ganttTasks.length;
  var gridWidth = dates.length * columnWidth;
  var ganttFullHeight = ganttTasks.length * rowHeight;
  useEffect(function () {
    setGanttTasks(tasks);
  }, [tasks]);
  useEffect(function () {
    var handleWheel = function handleWheel(event) {
      event.preventDefault();
      var newScrollY = scrollY + event.deltaY;

      if (newScrollY < 0) {
        setScrollY(0);
      } else if (newScrollY > ganttFullHeight - ganttHeight) {
        setScrollY(ganttFullHeight - ganttHeight);
      } else {
        setScrollY(newScrollY);
      }

      setIgnoreScrollEvent(true);
    };

    if (wrapperRef.current && ganttHeight && ganttHeight < ganttTasks.length * rowHeight) {
      wrapperRef.current.addEventListener("wheel", handleWheel, {
        passive: false
      });
    }

    return function () {
      if (wrapperRef.current) {
        wrapperRef.current.removeEventListener("wheel", handleWheel);
      }
    };
  }, [wrapperRef.current, scrollY, ganttHeight, ganttTasks, rowHeight]);

  var handleScrollY = function handleScrollY(event) {
    if (scrollY !== event.currentTarget.scrollTop && !ignoreScrollEvent) {
      setScrollY(event.currentTarget.scrollTop);
    }

    setIgnoreScrollEvent(false);
  };

  var handleScrollX = function handleScrollX(event) {
    if (scrollX !== event.currentTarget.scrollLeft && !ignoreScrollEvent) {
      setScrollX(event.currentTarget.scrollLeft);
    }

    setIgnoreScrollEvent(false);
  };

  var handleKeyDown = function handleKeyDown(event) {
    event.preventDefault();
    var newScrollY = scrollY;
    var newScrollX = scrollX;
    var isX = true;

    switch (event.key) {
      case "Down":
      case "ArrowDown":
        newScrollY += rowHeight;
        isX = false;
        break;

      case "Up":
      case "ArrowUp":
        newScrollY -= rowHeight;
        isX = false;
        break;

      case "Left":
      case "ArrowLeft":
        newScrollX -= columnWidth;
        break;

      case "Right":
      case "ArrowRight":
        newScrollX += columnWidth;
        break;
    }

    if (isX) {
      if (newScrollX < 0) {
        setScrollX(0);
      } else if (newScrollX > gridWidth) {
        setScrollX(gridWidth);
      } else {
        setScrollX(newScrollX);
      }
    } else {
      if (newScrollY < 0) {
        setScrollY(0);
      } else if (newScrollY > ganttFullHeight - ganttHeight) {
        setScrollY(ganttFullHeight - ganttHeight);
      } else {
        setScrollY(newScrollY);
      }
    }

    setIgnoreScrollEvent(true);
  };

  var handleTasksChange = function handleTasksChange(tasks) {
    setGanttTasks(tasks);
  };

  var handleSelectedTask = function handleSelectedTask(taskId) {
    var newSelectedTask = ganttTasks.find(function (t) {
      return t.id === taskId;
    });

    if (newSelectedTask) {
      if (onSelect) {
        var oldSelectedTask = ganttTasks.find(function (t) {
          return t.id === selectedTask;
        });

        if (oldSelectedTask) {
          onSelect(oldSelectedTask, false);
        }

        onSelect(newSelectedTask, true);
      }

      setSelectedTask(newSelectedTask.id);
    } else {
      if (onSelect) {
        var _oldSelectedTask = ganttTasks.find(function (t) {
          return t.id === selectedTask;
        });

        if (_oldSelectedTask) {
          onSelect(_oldSelectedTask, false);
        }
      }

      setSelectedTask("");
    }
  };

  var gridProps = {
    columnWidth: columnWidth,
    gridWidth: gridWidth,
    tasks: ganttTasks,
    rowHeight: rowHeight,
    dates: dates,
    todayColor: todayColor
  };
  var calendarProps = {
    dates: dates,
    locale: locale,
    viewMode: viewMode,
    headerHeight: headerHeight,
    columnWidth: columnWidth,
    fontFamily: fontFamily,
    fontSize: fontSize
  };
  var barProps = {
    tasks: ganttTasks,
    selectedTask: selectedTask,
    setSelectedTask: handleSelectedTask,
    rowHeight: rowHeight,
    barCornerRadius: barCornerRadius,
    columnWidth: columnWidth,
    dates: dates,
    barFill: barFill,
    barProgressColor: barProgressColor,
    barProgressSelectedColor: barProgressSelectedColor,
    barBackgroundColor: barBackgroundColor,
    barBackgroundSelectedColor: barBackgroundSelectedColor,
    handleWidth: handleWidth,
    arrowColor: arrowColor,
    timeStep: timeStep,
    fontFamily: fontFamily,
    fontSize: fontSize,
    arrowIndent: arrowIndent,
    svgHeight: svgHeight,
    onTasksChange: handleTasksChange,
    onDateChange: onDateChange,
    onProgressChange: onProgressChange,
    onDoubleClick: onDoubleClick,
    onTaskDelete: onTaskDelete,
    TooltipContent: TooltipContent
  };
  var tableProps = {
    rowHeight: rowHeight,
    rowWidth: listCellWidth,
    fontFamily: fontFamily,
    fontSize: fontSize,
    tasks: ganttTasks,
    locale: locale,
    headerHeight: headerHeight,
    scrollY: scrollY,
    ganttHeight: ganttHeight,
    horizontalContainerClass: styles$4.horizontalContainer,
    selectedTaskId: selectedTask,
    setSelectedTask: handleSelectedTask,
    TaskListHeader: TaskListHeader,
    TaskListTable: TaskListTable
  };
  return React.createElement("div", {
    className: styles$4.wrapper,
    onKeyDown: handleKeyDown,
    tabIndex: 0,
    ref: wrapperRef
  }, listCellWidth && React.createElement(TaskList, Object.assign({}, tableProps)), React.createElement(TaskGantt, {
    gridProps: gridProps,
    calendarProps: calendarProps,
    barProps: barProps,
    ganttHeight: ganttHeight,
    scrollY: scrollY,
    scrollX: scrollX,
    onScroll: handleScrollX
  }), React.createElement(Scroll, {
    ganttFullHeight: ganttFullHeight,
    ganttHeight: ganttHeight,
    headerHeight: headerHeight,
    scroll: scrollY,
    onScroll: handleScrollY
  }));
};

export { Gantt, ViewMode };
//# sourceMappingURL=index.modern.js.map
